{"ast":null,"code":"import { createElement, PureComponent } from 'react';\nimport InView from 'react-intersection-observer';\nimport invariant from 'invariant';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar isMonitoring = false;\nvar isScrolling = false;\nvar watchers = new Set();\n\nfunction onScroll(e) {\n  if (!isScrolling) {\n    isScrolling = true;\n    requestAnimationFrame(update);\n  }\n}\n\nfunction update() {\n  isScrolling = false;\n  watchers.forEach(function (cb) {\n    return cb();\n  });\n}\n\nfunction start() {\n  if (!isMonitoring) {\n    window.addEventListener('scroll', onScroll);\n    window.addEventListener('resize', onScroll);\n    isMonitoring = true;\n  }\n}\n\nfunction stop() {\n  if (isMonitoring) {\n    watchers.clear();\n    window.removeEventListener('scroll', onScroll);\n    window.removeEventListener('resize', onScroll);\n    isMonitoring = false;\n  }\n}\n\nfunction watch(cb) {\n  if (!isMonitoring) start();\n  watchers.add(cb);\n}\n\nfunction unwatch(cb) {\n  watchers.delete(cb);\n  if (!watchers.size) stop();\n}\n/**\n * Monitors scroll, and triggers the children function with updated props\n *\n <ScrollPercentage>\n {({inView, percentage}) => (\n   <h1>{`${inView} {percentage}`}</h1>\n )}\n </ScrollPercentage>\n */\n\n\nvar ScrollPercentage =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inheritsLoose(ScrollPercentage, _React$PureComponent);\n\n  function ScrollPercentage() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n      percentage: 0,\n      inView: false\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"node\", null);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleInView\", function (inView) {\n      _this.setState({\n        inView: inView\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleNode\", function (observer) {\n      return _this.node = observer && observer.node;\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleScroll\", function () {\n      if (!_this.node) return;\n      var threshold = _this.props.threshold;\n\n      var bounds = _this.node.getBoundingClientRect();\n\n      var percentage = ScrollPercentage.calculatePercentage(bounds, threshold);\n\n      if (percentage !== _this.state.percentage) {\n        _this.setState({\n          percentage: percentage\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"renderInner\", function (_ref) {\n      var inView = _ref.inView,\n          ref = _ref.ref;\n\n      var _this$props = _this.props,\n          children = _this$props.children,\n          onChange = _this$props.onChange,\n          threshold = _this$props.threshold,\n          innerRef = _this$props.innerRef,\n          tag = _this$props.tag,\n          props = _objectWithoutPropertiesLoose(_this$props, [\"children\", \"onChange\", \"threshold\", \"innerRef\", \"tag\"]); // Create a wrapping element\n\n\n      return createElement(tag || 'div', _extends({\n        ref: innerRef ? function (node) {\n          innerRef(node);\n          ref(node);\n        } : ref\n      }, props), typeof children === 'function' ? children({\n        percentage: _this.state.percentage,\n        inView: inView\n      }) : children);\n    });\n\n    return _this;\n  }\n\n  ScrollPercentage.viewportHeight = function viewportHeight() {\n    return global.parent ? global.parent.innerHeight : global.innerHeight || 0;\n  };\n\n  ScrollPercentage.calculatePercentage = function calculatePercentage(bounds, threshold) {\n    if (threshold === void 0) {\n      threshold = 0;\n    }\n\n    var vh = ScrollPercentage.viewportHeight();\n    var offsetTop = threshold * vh * 0.25;\n    var offsetBottom = threshold * vh * 0.25;\n    return 1 - Math.max(0, Math.min(1, (bounds.bottom - offsetTop) / (vh + bounds.height - offsetBottom - offsetTop)));\n  };\n\n  var _proto = ScrollPercentage.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    // Start by updating the scroll position, so it correctly reflects the elements start position\n    this.handleScroll();\n\n    if (process.env.NODE_ENV !== 'production') {\n      invariant(this.node, \"react-scroll-percentage: No DOM node found. Make sure you forward \\\"ref\\\" to the root DOM element you want to observe, when using render prop.\");\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    if (this.props.onChange && (prevState.percentage !== this.state.percentage || prevState.inView !== this.state.inView)) {\n      this.props.onChange(this.state.percentage, this.state.inView);\n    }\n\n    if (prevState.inView !== this.state.inView) {\n      this.monitorScroll(this.state.inView);\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.monitorScroll(false);\n  };\n\n  _proto.monitorScroll = function monitorScroll(enable) {\n    if (enable) {\n      watch(this.handleScroll);\n    } else {\n      unwatch(this.handleScroll);\n    }\n  };\n\n  _proto.render = function render() {\n    return createElement(InView, {\n      onChange: this.handleInView,\n      threshold: this.props.threshold,\n      ref: this.handleNode\n    }, this.renderInner);\n  };\n\n  return ScrollPercentage;\n}(PureComponent);\n\n_defineProperty(ScrollPercentage, \"defaultProps\", {\n  tag: 'div',\n  threshold: 0\n  /**\n   * Get the correct viewport height. If rendered inside an iframe, grab it from the parent\n   */\n\n});\n\nexport default ScrollPercentage;","map":null,"metadata":{},"sourceType":"module"}